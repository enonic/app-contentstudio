---
description: React component standards and best practices
globs: *.tsx
alwaysApply: false
---

# React Component Standards

## Component Structure

```typescript
// ✅ Always use functional components
// ✅ Define and export Props from the same component's file
// ✅ Always add component name before Props, e.g. `ButtonProps` for `Button` component
// ❌ Avoid using default export in component file

export type MyComponentProps = {
  title: string;
  // ✅ Drop prefixes for boolean flags
  active?: boolean;
  // ✅ Put `className?` and `children?` last in the Props definition
  className?: string;
  children?: ReactNode;
};

export function MyComponent({
  title,
  active = false,
  className,
  children,
}: MyComponentProps) {
  // ✅ Hoist store/ref hooks at the very top
  const data = useStore(myStore);
  const containerRef = useRef<HTMLDivElement>(null);

  // ✅ Other hooks next: state, memo, effects, etc.
  const [count, setCount] = useState(0);
  const expensive = useMemo(() => heavyCalc(data), [data]);

  // ✅ Effects are last hooks, if possible
  useEffect(() => { /* side-effect */ }, [data]);

  // ✅ If className list grows long, factor into `classNames` before return
  const classNames = twMerge(
    'p-4 rounded shadow',
    active && 'bg-blue-500',
    className,
  );

  // ✅ Early return for loading / error / guard clauses
  if (!data) return <LoadingIndicator />;

  // ✅ Set ARIA attributes where appropriate
  return (
    <div
      ref={containerRef}
      className={classNames}
      aria-pressed={active}
      role='button'
    >
      <h1>{title}</h1>
      {children}
    </div>
  );
}
```

## Variable Placement in Components

```typescript
export function MyComponent({ variant, disabled, className }: Props) {
  // 1️⃣ Hooks always first
  const [isOpen, setIsOpen] = useState(false);
  const data = useQuery();

  // 2️⃣ Derived state and business logic
  const isActive = data?.status === 'active';
  const showWarning = isActive && !disabled;

  // 3️⃣ Class variables - right before return/early returns
  const containerClasses = cn(
    'relative p-6 rounded-lg',
    isActive && 'ring-2 ring-blue-500',
    className,
  );

  const buttonClasses = cn(
    'px-4 py-2 font-medium',
    variant === 'primary' ? 'bg-blue-500 text-white' : 'bg-gray-200',
  );

  // 4️⃣ Early returns after class preparation
  if (!data) return <Loading />;

  // 5️⃣ JSX with prepared variables
  return (
    <div className={containerClasses}>
      <button className={buttonClasses}>
        Click me
      </button>
    </div>
  );
}
```

## Component Display Names

```typescript
// ✅ Arrow functions: MUST set displayName
export const Button = ({ children }: ButtonProps) => <button>{children}</button>;
Button.displayName = 'Button';

// ✅ memo(): MUST set displayName
export const List = React.memo(({ items }: Props) => <ul>...</ul>);
List.displayName = 'List';

// ✅ forwardRef(): MUST set displayName
export const Input = React.forwardRef<HTMLInputElement, Props>((props, ref) => <input ref={ref} />);
Input.displayName = 'Input';

// ✅ HOCs: MUST set displayName with wrapper info
const withAuth = <P,>(Component: React.ComponentType<P>) => {
  const Wrapped = (props: P) => { /* ... */ };
  Wrapped.displayName = \`withAuth(\${Component.displayName || Component.name})\`;
  return Wrapped;
};

// ❌ Function declarations: displayName NOT needed (auto-inferred)
export function UserCard({ name }: Props) { return <div>{name}</div>; }
```

**Check for missing displayName when:**

- Component uses arrow function syntax: `const X = () => ...`
- Component wrapped with `React.memo()` or `React.forwardRef()`
- Component returned from HOC

**Skip displayName check when:**

- Component uses `function` declaration syntax

## useEffect Best Practices

```typescript
// ❌ DON'T: Transform data for rendering
function TodoList({ todos, filter }) {
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(todos.filter(todo => todo.status === filter));
  }, [todos, filter]); // Unnecessary effect!
}

// ✅ DO: Calculate during render
function TodoList({ todos, filter }) {
  const visibleTodos = todos.filter(todo => todo.status === filter);
  // Or useMemo if expensive: useMemo(() => todos.filter(...), [todos, filter])
}

// ❌ DON'T: Handle user events
function Form() {
  const [submitted, setSubmitted] = useState(false);
  useEffect(() => {
    if (submitted) {
      sendAnalytics('form_submit');
      // ... more submission logic
    }
  }, [submitted]); // Wrong pattern!
}

// ✅ DO: Use event handlers directly
function Form() {
  const handleSubmit = () => {
    sendAnalytics('form_submit');
    // ... submission logic
  };
}

// ❌ DON'T: Reset state when prop changes
function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');
  useEffect(() => {
    setComment(''); // Reset comment when user changes
  }, [userId]); // Can be better!
}

// ✅ DO: Use key prop to reset component state
function ProfilePage({ userId }) {
  return <Profile key={userId} userId={userId} />;
  // Component remounts, state resets automatically
}

// ❌ DON'T: Update state based on props/state changes
function UserCard({ firstName, lastName }) {
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(`${firstName} ${lastName}`);
  }, [firstName, lastName]); // Redundant state sync!
}

// ✅ DO: Calculate during render
function UserCard({ firstName, lastName }) {
  const fullName = `${firstName} ${lastName}`; // Just derive it
}

// ✅ CORRECT uses of useEffect:
// External system sync
useEffect(() => {
  const ws = new WebSocket(url);
  ws.connect();
  return () => ws.disconnect();
}, [url]);

// Data fetching (though prefer React Query/SWR)
useEffect(() => {
  fetch(`/api/user/${userId}`)
    .then(res => res.json())
    .then(setUser);
}, [userId]);

// Analytics/logging after render
useEffect(() => {
  logPageView(pathname);
}, [pathname]);
```

## useCallback Best Practices

```typescript
// ❌ DON'T use useCallback when:
// - Not passed to memo() components
// - Not used as dependency in hooks
// - Function doesn't capture scope values
const handleClick = useCallback(() => console.log('click'), []); // Unnecessary!

// ✅ DO use useCallback when:
// - Passing to memo() components
const handleClick = useCallback(() => setCount(c => c + 1), []);
return <MemoizedButton onClick={handleClick} />;

// - Function is dependency of other hooks
const fetchData = useCallback(() => fetch(url), [url]);
useEffect(() => { fetchData() }, [fetchData]);
```

## useMemo Best Practices

```typescript
// ❌ DON'T use useMemo for:
// - Simple calculations
const sum = useMemo(() => a + b, [a, b]); // Overkill!
// - Primitives that aren't dependencies
const name = useMemo(() => user.name, [user.name]); // Unnecessary!

// ✅ DO use useMemo for:
// - Expensive calculations (filtering/sorting large arrays)
const filtered = useMemo(() => bigArray.filter(...).sort(...), [bigArray]);

// - Objects/arrays passed to memo() children or used as dependencies
const options = useMemo(() => ({ sort: true, filter }), [filter]);
return <MemoizedList options={options} />;
```

## Extending Component Props

```typescript
// ✅ DO: Use ComponentPropsWithoutRef for standard components
import { ComponentPropsWithoutRef } from 'react';

type ButtonProps = {
  variant?: 'primary' | 'secondary';
  loading?: boolean;
} & ComponentPropsWithoutRef<'button'>;

export function Button({ variant = 'primary', loading, ...props }: ButtonProps) {
  return <button {...props} />;
}

// ✅ DO: Use ComponentPropsWithRef when forwarding refs
import { ComponentPropsWithRef, forwardRef } from 'react';

type InputProps = {
  label?: string;
  error?: string;
} & ComponentPropsWithRef<'input'>;

export const Input = forwardRef<HTMLInputElement, InputProps>(
  ({ label, error, ...props }, ref) => {
    return <input ref={ref} {...props} />;
  }
);

// ❌ DON'T: Use ComponentProps (doesn't distinguish ref handling)
type BadProps = { value: string } & ComponentProps<'input'>; // Avoid

// ❌ DON'T: Use specific HTML attribute types
type BadButtonProps = { variant: string } & ButtonHTMLAttributes<HTMLButtonElement>; // Verbose
type BadDivProps = { layout: string } & HTMLAttributes<HTMLDivElement>; // Unnecessary
```

## Performance Patterns

```typescript
// 1️⃣ Keep renders cheap & predictable
// ✅ Split UI into small, pure components; wrap heavy ones in React.memo
const ImageGrid = React.memo(function ImageGrid({ images }: { images: Image[] }) {
  return images.map(img => <img key={img.id} src={img.src} />);
});

// 2️⃣ `useMemo` only for **expensive** calculations or reference-equality
// ✅ Heavy work
const sorted = useMemo(() => heavySort(list), [list]);  // good
// ❌ Cheap math doesn't need it
const sum = a + b;                                      // simpler + faster

// 3️⃣ `useCallback` only when a child​/​hook depends on function identity
// ✅ Stable handler passed to memoized child
const handleSave = useCallback((u: User) => onSave(u), [onSave]);
<SaveButton onClick={handleSave} />;

// ❌ Redundant inside same component scope
<button onClick={() => onSave(user)}>Save</button>      // fine—re-creation is cheap

// 4️⃣ Prefer `useEffect`; reserve `useLayoutEffect` for sync DOM reads/writes
// ✅ Measure before paint, then mutate quickly
useLayoutEffect(() => {
  const rect = ref.current!.getBoundingClientRect();
  setPos(rect.top);
}, []); // keep work minimal & cleanup promptly

// 5️⃣ Throttle / debounce high-frequency events (scroll, resize)
// ✅ Check and apply to cases, where no fast/instant feedback is needed
const throttledScroll = useCallback(throttle(handleScroll, 100), [handleScroll]);

// 6️⃣ If store is a map, listen for the used keys only
const { account } = useStore($application, {keys: ['account']});
```
